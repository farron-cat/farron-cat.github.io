import{_ as d,C as a,c as s,o as f,ae as t,j as i,a as u,G as r,w as o}from"./chunks/framework.U1Gow_7P.js";const j=JSON.parse('{"title":"第八章 排序","description":"","frontmatter":{},"headers":[],"relativePath":"programming/data_structure/chap8.md","filePath":"programming/data_structure/chap8.md"}'),m={name:"programming/data_structure/chap8.md"},p={id:"总结对比",tabindex:"-1"};function T(e,l,g,A,P,b){const n=a("font");return f(),s("div",null,[l[39]||(l[39]=t('<h1 id="第八章-排序" tabindex="-1">第八章 排序 <a class="header-anchor" href="#第八章-排序" aria-label="Permalink to &quot;第八章 排序&quot;">​</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><ul><li>稳定性</li><li>衡量标准 <ul><li>时间复杂度</li><li>空间复杂度</li></ul></li></ul><h2 id="内部排序" tabindex="-1">内部排序 <a class="header-anchor" href="#内部排序" aria-label="Permalink to &quot;内部排序&quot;">​</a></h2><h3 id="插入排序" tabindex="-1">插入排序 <a class="header-anchor" href="#插入排序" aria-label="Permalink to &quot;插入排序&quot;">​</a></h3>',5)),i("ul",null,[l[12]||(l[12]=i("li",null,[u("直接插入排序 "),i("ul",null,[i("li",null,"代码 增序 ![图片](./第八章 排序-幕布图片-80117-148846.jpg)"),i("li",null,[u("分析 "),i("ul",null,[i("li",null,"时间"),i("li",null,"空间"),i("li",null,"稳定性")])])])],-1)),i("li",null,[l[11]||(l[11]=u("折半插入排序 ",-1)),i("ul",null,[i("li",null,[l[10]||(l[10]=u("插入排序的一种优化方式 ",-1)),i("ul",null,[l[7]||(l[7]=i("li",null,"将在有序子表中查找待插入元素的位置的方式改为二分查找",-1)),i("li",null,[r(n,{color:"#FFAF38"},{default:o(()=>l[0]||(l[0]=[u("在查找结束时low>high，low所指位置为元素插入位置",-1)])),_:1,__:[0]}),l[1]||(l[1]=i("ul",null,[i("li",null,"此时应将有序子表中从最后一个位置依次右移到low空出")],-1))]),l[8]||(l[8]=i("li",null,"仅减少比较元素次数，O(nlogn)",-1)),l[9]||(l[9]=i("li",null,"时间复杂度仍为O(n^2)",-1)),i("li",null,[l[6]||(l[6]=u("稳定性：稳定 ",-1)),i("ul",null,[i("li",null,[l[3]||(l[3]=u("为了 ",-1)),r(n,{color:"#FFAF38"},{default:o(()=>l[2]||(l[2]=[u("保证稳定性",-1)])),_:1,__:[2]}),l[4]||(l[4]=u(" 在A[mid]==A[0] 时仍要在mid右侧进行查找",-1))]),l[5]||(l[5]=i("li",null,"即A[mid]<=A[0] 时 low=mid+1",-1))])])])])])]),l[13]||(l[13]=t("<li>链表的插入排序 <ul><li>元素移动次数减少，但比较次数依然O(n^2)</li></ul></li><li>希尔排序 ![图片](./第八章 排序-幕布图片-88934-557766.jpg)</li><li>又称 缩小增量排序</li><li>思想 <ul><li>将相距距离为d的元素分在同一个子表中，对子表进行插入排序</li><li>逐渐缩小d的值，重复上述直到d==1</li></ul></li><li>增量序列一般为每次折半向下取整 <ul><li>4 2 1</li></ul></li><li>只适用于线性表为顺序存储（顺序表） <ul><li>存在步长d 要求随机存储</li></ul></li>",6))]),l[40]||(l[40]=i("h3",{id:"交换排序",tabindex:"-1"},[u("交换排序 "),i("a",{class:"header-anchor",href:"#交换排序","aria-label":'Permalink to "交换排序"'},"​")],-1)),i("ul",null,[i("li",null,[l[18]||(l[18]=u("冒泡排序 降序 从后往前 ![图片](./第八章 排序-幕布图片-11658-467918.jpg) ",-1)),i("ul",null,[l[15]||(l[15]=i("li",null,"n-1趟，每趟确定一个最小（最大）",-1)),i("li",null,[r(n,{color:"#FFAF38"},{default:o(()=>l[14]||(l[14]=[u("一趟没有交换则已经有序",-1)])),_:1,__:[14]})]),l[16]||(l[16]=i("li",null,"A[j-1]=A[j]时不交换保证稳定",-1)),l[17]||(l[17]=i("li",null,"适用于链表",-1))])]),i("li",null,[r(n,{color:"#DC2D1E"},{default:o(()=>l[19]||(l[19]=[u("快速排序",-1)])),_:1,__:[19]}),l[20]||(l[20]=u(" ![图片](./第八章 排序-幕布图片-308573-595683.jpg)",-1))]),l[21]||(l[21]=t("<li>基本思想：分治</li><li>所以内排中平均性能最优</li><li>每趟会将枢轴放到最终位置上</li><li>空间复杂度 O(n*递归层数) <ul><li>最好 O(logn)</li><li>最坏 O(n)</li></ul></li><li>时间复杂度 O(n*递归层数) <ul><li>最好 O(nlogn) 划分最平衡</li><li>最坏 O(n^2) 划分最大限度不对称</li></ul></li><li>稳定性：不稳定</li><li>优化 <ul><li>尽量选取能将数据中分的枢轴</li><li>取待排表头尾中间三个数据，将三者中间值为枢轴</li><li>随机选取待排元素</li></ul></li>",7))]),l[41]||(l[41]=i("h3",{id:"选择排序",tabindex:"-1"},[u("选择排序 "),i("a",{class:"header-anchor",href:"#选择排序","aria-label":'Permalink to "选择排序"'},"​")],-1)),i("ul",null,[l[24]||(l[24]=i("li",null,[u("简单选择 ![图片](./第八章 排序-幕布图片-452403-164060.jpg) "),i("ul",null,[i("li",null,"每次选择最大或最小元素与表头元素交换，然后缩小规模"),i("li",null,"也适用于链表")])],-1)),i("li",null,[r(n,{color:"#DC2D1E"},{default:o(()=>l[22]||(l[22]=[u("堆排序",-1)])),_:1,__:[22]}),l[23]||(l[23]=t(" ![图片](./第八章 排序-幕布图片-745059-980781.jpg) ![图片](./第八章 排序-幕布图片-83865-652386.jpg)<ul><li>堆 <ul><li>分类 <ul><li>大根堆 <ul><li>顺序存储的完全二叉树，根&gt;=左、右</li></ul></li><li>小根堆</li></ul></li><li>大根堆建立 <ul><li>将数据按顺序写成完全二叉树形式</li><li>所有非终端节点都检查</li><li>从最后一个非终端节点开始</li><li>从下往上，大的向上换，小的不断下坠</li><li>建堆过程关键字对比不超过4n次，建堆时间复杂度O(n)</li></ul></li><li>插入 <ul><li>先将元素节点放在堆的末端</li><li>对这个新节点向上调整，直到无法上升</li><li>上升调整只需对比关键字1次</li></ul></li><li>删除 <ul><li>将元素节点删除后，用堆最后一个节点补</li><li>再将该补充节点从上到下下坠到底进行调整</li><li>下坠调整只需对比关键字2次</li></ul></li></ul></li><li>堆排序 <ul><li>每一趟将堆顶元素加入有序序列中</li><li>将其与堆中最后一个元素交换</li><li>从上到下，下坠调整 <ul><li>树高h，某节点在i层，调整这个节点最多下坠h-i层，关键字对比次数不超过2(h-2)次</li></ul></li></ul></li></ul>",2))])]),l[42]||(l[42]=i("h3",{id:"归并排序",tabindex:"-1"},[u("归并排序 "),i("a",{class:"header-anchor",href:"#归并排序","aria-label":'Permalink to "归并排序"'},"​")],-1)),i("ul",null,[l[29]||(l[29]=t("<li>归并：把几个有序的序列合并成一个</li><li>2路 用于内部排序 ![图片](./第八章 排序-幕布图片-707212-421469.jpg) ![图片](./第八章 排序-幕布图片-526629-954522.jpg)</li><li>思想 <ul><li>low&lt;high 从mid分成左右两段</li><li>对左右两段递归地进行归并排序</li><li>将左右两段有序序列合并为一个</li></ul></li><li>归并树</li><li>每趟为什么O(n) <ul><li>第一次归并，n/2组两两对比，比较次数约为n/2次</li><li>最后一次归并，两段归并为一段，两两比较次数&lt;=n-1次</li></ul></li><li>空间复杂度 <ul><li>递归深度不超过logn，递归工作栈为O(logn)</li><li>辅助数组O(n)</li><li>O(logn)+O(n)=O(n)</li></ul></li>",6)),i("li",null,[l[26]||(l[26]=u("元素相等时优先将在前一段的元素放入最终序列中保证 ",-1)),r(n,{color:"#FFAF38"},{default:o(()=>l[25]||(l[25]=[u("稳定",-1)])),_:1,__:[25]}),l[27]||(l[27]=i("ul",null,[i("li",null,"B[i]<=B[j]")],-1))]),i("li",null,[r(n,{color:"#DC2D1E"},{default:o(()=>l[28]||(l[28]=[u("k路",-1)])),_:1,__:[28]})])]),l[43]||(l[43]=i("h3",{id:"基数排序-图片-第八章-排序-幕布图片-650078-537076-jpg",tabindex:"-1"},[u("基数排序 ![图片](./第八章 排序-幕布图片-650078-537076.jpg) "),i("a",{class:"header-anchor",href:"#基数排序-图片-第八章-排序-幕布图片-650078-537076-jpg","aria-label":'Permalink to "基数排序 ![图片](./第八章 排序-幕布图片-650078-537076.jpg)"'},"​")],-1)),l[44]||(l[44]=i("ul",null,[i("li",null,"借助队列，链式结构"),i("li",null,"分配和收集"),i("li",null,"不是基于关键字的比较")],-1)),l[45]||(l[45]=i("h3",{id:"应用",tabindex:"-1"},[u("应用 "),i("a",{class:"header-anchor",href:"#应用","aria-label":'Permalink to "应用"'},"​")],-1)),i("ul",null,[i("li",null,[r(n,{color:"#FFAF38"},{default:o(()=>l[30]||(l[30]=[u("10000",-1)])),_:1,__:[30]}),l[32]||(l[32]=u(" 学生信息要按年龄 ",-1)),r(n,{color:"#40A8F5"},{default:o(()=>l[31]||(l[31]=[u("递减",-1)])),_:1,__:[31]}),l[33]||(l[33]=u(" 排序",-1)),l[34]||(l[34]=i("ul",null,[i("li",null,[u("信息中有生日：年>月>日 日期越大的年龄越小 "),i("ul",null,[i("li",null,"先按日递增"),i("li",null,"再按月递增"),i("li",null,"再按年递增")])])],-1))]),l[35]||(l[35]=i("li",null,[u("适合 "),i("ul",null,[i("li",null,"关键字可分为n元组，且组数不多"),i("li",null,"每组取值范围不大"),i("li",null,"数据元素n较大")])],-1))]),i("h3",p,[r(n,{color:"#DC2D1E"},{default:o(()=>l[36]||(l[36]=[u("总结对比",-1)])),_:1,__:[36]}),l[37]||(l[37]=u()),l[38]||(l[38]=i("a",{class:"header-anchor",href:"#总结对比","aria-label":'Permalink to "<font color=#DC2D1E>总结对比</font>"'},"​",-1))]),l[46]||(l[46]=i("h2",{id:"外部排序",tabindex:"-1"},[u("外部排序 "),i("a",{class:"header-anchor",href:"#外部排序","aria-label":'Permalink to "外部排序"'},"​")],-1)),l[47]||(l[47]=i("ul",null,[i("li",null,"多路归并排序"),i("li",null,"败者树"),i("li",null,"置换-选择排序"),i("li",null,"最佳归并树")],-1))])}const O=d(m,[["render",T]]);export{j as __pageData,O as default};
