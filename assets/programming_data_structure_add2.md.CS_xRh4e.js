import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.B8KKhRA6.js";const _=JSON.parse('{"title":"并查集","description":"","frontmatter":{},"headers":[],"relativePath":"programming/data_structure/add2.md","filePath":"programming/data_structure/add2.md"}'),r={name:"programming/data_structure/add2.md"};function o(n,l,u,d,s,h){return e(),a("div",null,l[0]||(l[0]=[t('<h1 id="并查集" tabindex="-1">并查集 <a class="header-anchor" href="#并查集" aria-label="Permalink to &quot;并查集&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><ul><li>逻辑结构：集合</li><li>用于分类</li><li>有合并和查找功能的集合</li><li>各个集合间元素不相交</li></ul><h2 id="基本操作" tabindex="-1">基本操作 <a class="header-anchor" href="#基本操作" aria-label="Permalink to &quot;基本操作&quot;">​</a></h2><ul><li>Initial(S)</li><li>FInd(S,x)</li><li>Union(S,Root1,Root2)</li></ul><h2 id="存储结构" tabindex="-1">存储结构 <a class="header-anchor" href="#存储结构" aria-label="Permalink to &quot;存储结构&quot;">​</a></h2><ul><li>顺序存储</li><li>每个集合组织成一棵树，用树的双亲表示法</li><li>根结点的内容为负值，其绝对值为该集合中结点的个数</li></ul><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><ul><li>Union(S,Root1,Root2)的优化 <ul><li>针对Find(S,x)最坏时间复杂度O(n)，原因是树高不受控制</li><li>在每次Union构建树时，尽可能让树的高度不增加。</li><li>通过比较集合内元素个数判断大小，每次都让小的成为大的的子树</li><li>代码</li><li>优化后构造的树高不超过（logn）下取整+1</li></ul></li><li>Find(S,x)的优化 <ul><li>压缩路径</li><li>循环两次，第一次先找到根，第二次让找根路径上的所有结点挂在根结点下</li><li>代码</li><li>优化后使树高不超过O(α(n))</li></ul></li></ul><h2 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h2><ul><li>判断图的连通分量数 <ul><li>遍历各条边，有边相连的两个顶点一定是连通的</li><li>将两个顶点所属集合合并为一个集合</li><li>处理完所有边，即可将图划分为若干个连通分量</li><li>记录并查集中根结点数量即为连通分量数</li></ul></li><li>判断图是否有环 <ul><li>在上述遍历各边的过程中出现边的两端顶点已经在同一集合中，则必有环</li></ul></li><li>Kruskal算法 <ul><li>使用并查集排除加上后产生环的边</li></ul></li></ul>',11)]))}const m=i(r,[["render",o]]);export{_ as __pageData,m as default};
