# 第八章 排序
- 基本概念
    - 稳定性
    - 衡量标准
        - 时间复杂度
        - 空间复杂度
- 内部排序
    - 插入排序
        - 直接插入排序
            - 代码    增序 ![图片](./第八章 排序-幕布图片-80117-148846.jpg)
            - 分析
                - 时间
                - 空间
                - 稳定性
        - 折半插入排序
            - 插入排序的一种优化方式
                - 将在有序子表中查找待插入元素的位置的方式改为二分查找
                - <font color=#FFAF38>在查找结束时low>high，low所指位置为元素插入位置</font>
                    - 此时应将有序子表中从最后一个位置依次右移到low空出
                - 仅减少比较元素次数，O(nlogn)
                - 时间复杂度仍为O(n^2)
                - 稳定性：稳定
                    - 为了 <font color=#FFAF38>保证稳定性</font> 在A[mid]==A[0] 时仍要在mid右侧进行查找
                    - 即A[mid]<=A[0] 时 low=mid+1
        - 链表的插入排序
            - 元素移动次数减少，但比较次数依然O(n^2)
        - 希尔排序 ![图片](./第八章 排序-幕布图片-88934-557766.jpg)
        - 又称 缩小增量排序
        - 思想
            - 将相距距离为d的元素分在同一个子表中，对子表进行插入排序
            - 逐渐缩小d的值，重复上述直到d==1
        - 增量序列一般为每次折半向下取整
            - 4 2 1
        - 只适用于线性表为顺序存储（顺序表）
            - 存在步长d 要求随机存储
    - 交换排序
        - 冒泡排序    降序  从后往前 ![图片](./第八章 排序-幕布图片-11658-467918.jpg)
            - n-1趟，每趟确定一个最小（最大）
            - <font color=#FFAF38>一趟没有交换则已经有序</font>
            - A[j-1]=A[j]时不交换保证稳定
            - 适用于链表
        - <font color=#DC2D1E>快速排序</font> ![图片](./第八章 排序-幕布图片-308573-595683.jpg)
        - 基本思想：分治
        - 所以内排中平均性能最优
        - 每趟会将枢轴放到最终位置上
        - 空间复杂度 O(n*递归层数)
            - 最好 O(logn)
            - 最坏 O(n)
        - 时间复杂度 O(n*递归层数)
            - 最好 O(nlogn)  划分最平衡
            - 最坏 O(n^2) 划分最大限度不对称
        - 稳定性：不稳定
        - 优化
            - 尽量选取能将数据中分的枢轴
            - 取待排表头尾中间三个数据，将三者中间值为枢轴
            - 随机选取待排元素
    - 选择排序
        - 简单选择 ![图片](./第八章 排序-幕布图片-452403-164060.jpg)
            - 每次选择最大或最小元素与表头元素交换，然后缩小规模
            - 也适用于链表
        - <font color=#DC2D1E>堆排序</font> ![图片](./第八章 排序-幕布图片-745059-980781.jpg) ![图片](./第八章 排序-幕布图片-83865-652386.jpg)
            - 堆
                - 分类
                    - 大根堆
                        - 顺序存储的完全二叉树，根>=左、右
                    - 小根堆
                - 大根堆建立
                    - 将数据按顺序写成完全二叉树形式
                    - 所有非终端节点都检查
                    - 从最后一个非终端节点开始
                    - 从下往上，大的向上换，小的不断下坠
                    - 建堆过程关键字对比不超过4n次，建堆时间复杂度O(n)
                - 插入
                    - 先将元素节点放在堆的末端
                    - 对这个新节点向上调整，直到无法上升
                    - 上升调整只需对比关键字1次
                - 删除
                    - 将元素节点删除后，用堆最后一个节点补
                    - 再将该补充节点从上到下下坠到底进行调整
                    - 下坠调整只需对比关键字2次
            - 堆排序
                - 每一趟将堆顶元素加入有序序列中
                - 将其与堆中最后一个元素交换
                - 从上到下，下坠调整
                    - 树高h，某节点在i层，调整这个节点最多下坠h-i层，关键字对比次数不超过2(h-2)次
    - 归并排序
        - 归并：把几个有序的序列合并成一个
        - 2路 用于内部排序 ![图片](./第八章 排序-幕布图片-707212-421469.jpg) ![图片](./第八章 排序-幕布图片-526629-954522.jpg)
        - 思想
            - low<high 从mid分成左右两段
            - 对左右两段递归地进行归并排序
            - 将左右两段有序序列合并为一个
        - 归并树
        - 每趟为什么O(n)
            - 第一次归并，n/2组两两对比，比较次数约为n/2次
            - 最后一次归并，两段归并为一段，两两比较次数<=n-1次
        - 空间复杂度
            - 递归深度不超过logn，递归工作栈为O(logn)
            - 辅助数组O(n)
            - O(logn)+O(n)=O(n)
        - 元素相等时优先将在前一段的元素放入最终序列中保证 <font color=#FFAF38>稳定</font>
            - B[i]<=B[j]
        - <font color=#DC2D1E>k路</font>
    - 基数排序 ![图片](./第八章 排序-幕布图片-650078-537076.jpg)
        - 借助队列，链式结构
        - 分配和收集
        - 不是基于关键字的比较
    - 应用
        - <font color=#FFAF38>10000</font> 学生信息要按年龄 <font color=#40A8F5>递减</font> 排序
            - 信息中有生日：年>月>日   日期越大的年龄越小
                - 先按日递增
                - 再按月递增
                - 再按年递增
        - 适合
            - 关键字可分为n元组，且组数不多
            - 每组取值范围不大
            - 数据元素n较大
    - <font color=#DC2D1E>总结对比</font>
        - 
- 外部排序
    - 多路归并排序
    - 败者树
    - 置换-选择排序
    - 最佳归并树